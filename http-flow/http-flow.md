웹은 **클라이언트** 와 **서버** 의 상호작용이다. 다른 누군가와 통신하려면 통신 규약이 필요하다. HTTP, Hyper Text Transfer Protocol이 웹의 통신 규약(방법)이다.
**클라이언트**와 **서버**의 통신 과정을 짚어본다.

## 메시지의 흐름

### IP
Internet Protocol. 인터넷의 각 장치를 나타내는 주소를 말한다. 통신의 대상을 구별하는데 쓰인다.  
`URL`은 자원을 식별하는데 쓰였다. `IP`는 네트워크 상 노드, 즉 컴퓨터를 식별하는데 쓰인다.

### Private, Public IP
사설 IP, 공용 IP라고도 불린다.
`LAN`에서 사용되는 것이 사설 IP,  
`WAN`에서 사용되는 것이 공용 IP이다.

#### LAN
Local Area Network. 지역 네트워크다. 사설 IP는 공유기(DHCP 서버) 하위에서 유효한 IP 주소로, 지역 네트워크에서는 서로를 식별할 수 있다.  
당연하지만 `WAN`에서는 사설 IP로 식별 불가능하다. 오직 `LAN`에서만 식별 가능하다.  
ISP(Internet Service Provider, 통신사)는 각 사용자마다 IP를 할당하기 매우 어려우므로(IP고갈) 하나의 공용IP를 제공한다.  
또, `WAN`으로 통신하는 것보다 지역 내에서 통신하는 것이 훨씬 효율적이므로 `LAN`을 사용하기도 한다.  
예를 들면 `our-generation.com`을 서비스하는 웹 서버와 DB를 지역 네트워크, `LAN`으로 묶으면 네트워크를 효율적으로 사용할 수 있다.  

하나의 공용IP를 여러 사설 IP로 쪼개어 사용할 수 있게 하는 것이 `DHCP` 혹은 공유기라고 부른다. 이 공유기를 통해서 여러 디바이스가 인터넷을 이용할 수 있다.  

#### WAN
Wide Area Network. 소위 말하는 인터넷이다. 서울 잠실 루터회관에서 출발한 메시지가 미국 시애틀의 aws로 도달할 수 있게 한다. 어느 곳에서나 같은 `IP`로 대상에 접근할 수 있다.  
공용 `IP`는 등록 절차가 있다. ISP가 IP 여러개를 가지고 있다가, 서비스를 요청하면 IP하나를 할당해 준다. 때문에 공용 IP로 약간의 개인정보를 추측할 수 있다. `12.34.56.78`의 IP를 보고 어느 위치에서 접속했는지, 국적이 어딘지, 어떤 서비스를 이용중인지 알 수 있다. [참고 - myip.com](https://www.myip.com)

> Quiz) 집에서 서버 하나를 만들었다. 친구에게 보여 주고 싶어서 해당 IP로 접속해 보라고 연락했다. 친구는 접속할 수 있을까?
> 접속하게 하려면 어떻게 해야 할까? hint - 포트포워딩

#### IPv4, IPv6
대부분의 PC에서 IP를 조회해 보면 `192.168.xxx.xxx`로 나타날 것이다. 이것은 IP 중에서도 `IPv4`를 나타낸다.    
IPv4는 3자리 숫자 4개를 조합하여 의미를 갖는다. 각 자리는 `0~255`까지 숫자로 나타낸다. IP로 나타낼 수 있는 주소의 한계는 256의 4제곱이다. (4,294,967,296‬ 약 42억개)
매우 큰 수지만, 인터넷이 폭발적으로 성장하면서 IPv4는 거의 고갈되었다.  
이 문제 때문에 `IPv6`가 나왔다. 아직 많이 사용되고 있지는 않다.(`WAN`을 구성하는 많은 네트워크 장비가 IPv6를 처리하지 못한다. 이 장비들의 교체에는 천문학적 비용이 든다)  

IPv4가 나타낼 수 있는 범위는 앞에서 보았듯 `2^32` 개이고,  
Ipv6가 나타낼 수 있는 범위는 `2^128` 개이다. 42억개의 4제곱이다. ...

### DNS

Domain Name System 이다. 도메인 네임을 IP주소로 변환해준다.  
`WAN`에서 모든 네트워크는 IP를 따라 이동하지만, 인간이 4개 숫자를 외우고 다니는 것이 매우 힘들다. `Domain Name`을 `IP`로 바꿔주는 서비스가 DNS다. 
터미널을 열고 다음 명령을 실행해 보자.

```bash
// for macOS Or Linux
$ ifconfig | grep inet

// for Windows
$ ipconfig
```

터미널에 나오는 xxx.xxx.xxx.xxx 숫자가 바로 자신 컴퓨터의 **IP** 이다.  
`github.com` 의 IP 주소는 `15.164.81.167` 이다. 주소창에 15.164.81.167 을 입력해 보시라. 무엇이 나오나? `github.com`이 나온다. `15.164.81.167`가 `github.com`의 공용 IP이다.   

특정 IP에 대한 **이름**이 도메인이다. `github.com`, `naver.com`, `google.com` 등이 도메인이다. 도메인은 선점효과가 있기 때문에, **비용을 내고** 도메인 네임 서비스에 등록한다. 도메인에서 가리킬 IP를 등록하면, DNS가 IP로 변환해 준다!

`github.com`을 사용자가 입력했을 때, 브라우저는 요청 대상 주소가 `Domain Name`임을 알게 된다.  
브라우저가 필요한 것은 IP이므로, DNS에 IP를 질의하고 나서 해당 IP로 요청을 송신한다.

매번 DNS에 물어보면 여러모로 효율적이지 못하니, 한번 방문한 사이트는 IP정보를 보관(캐시)한다.  
많은 보이스피싱 조직이 이 IP캐시를 이용하여 정보를 탈취하는 것으로 알려져 있다.

### 라우터

`github.com` 서버는 아주 멀리 떨어져 있다. _(정확히 어디에 있는지는 모르겠지만, 바다 건너 있는건 확실하다)_ 어떻게 내 컴퓨터에서 요청한 내용을 `github.com` 은 건네줄 수 있을까? 내가 보낸 요청을 `github.com` 은 어떻게 받아보는 것일까?

웹은 인터넷 위에서 동작한다. 인터넷은 어마무시하게 많은 노드가 있는 네트워크다. 내 요청은 네트워크 바다 한 귀퉁이에서 반대편 한 귀퉁이로 이동해야 한다. **라우터**는 네트워크의 한 영역의 패킷을 다른 영역으로 보내는 역할을 한다. 라우터는 OSI 7 계층에서 `3 - Network layer` 에 속한다. 

즉, 내가 보낸 요청은 **바로** `github.com` 에 도착하는게 아니라, **여러번의 라우팅을 거쳐** 도달한다.  
터미널에서 다음 명령을 실행해 보자.

```bash
$ traceroute github.com
// 1. xxx.xxx.xxx.xxx ...
// 2. xxx.xxx.xxx.xxx ...
...
```

`traceroute` 는 라우팅 과정을 추적하는 명령어다. `trace + route` `github.com` 으로 보낸 메시지가 여러 라우터를 거쳐가는 것을 확인할 수 있을 것이다.

### 프락시 Proxy

Proxy Server. 클라이언트와 서버 사이를 중개한다. 클라이언트에게는 서버인 척, 서버에게는 클라이언트인 척 한다.    
프락시는 종류가 굉장히 많은데, 여기서는 캐시 프락시를 이야기한다.  

`naver.com`을 상상해보자. 하루 몇번의 요청이 있을까? 오천만 국민 중 네이버를 모르는 사람 없을 것이다. 종이신문은 네이버가 대체한지 오래다. 하루 몇 천만번을 뛰어넘는 요청이 쇄도할 것이다.  
그런데, 단순한 요청이 많다. 네이버 메인페이지("/"), 뉴스 란, 웹툰 란 ... 뭔가 연산을 해야 한다기 보다는 `html`, `jpg` 등 정적 자원`static resource`인 경우가 훨씬 많다.  
많은 요청을 위해 서버를 얼마나 늘려야 할까? 아주 많이 필요할 것이다. 이럴 때 프락시가 좋은 선택이 된다.  
프락시는 `cache`캐시를 갖고 있다. 네이버 메인 페이지를 갖고 있다가, 메인 페이지 요청이 들어오면 `naver.com`으로 요청을 보내지 않고 자신이 갖고 있는 메인 페이지를 클라리언트에 준다.  
클라이언트가 로그인을 시도하면 프락시는 자신이 처리할 수 없음을 알고 `naver.com`으로 요청을 전송해준다.   

`naver.com` 서버 입장에서는 클라이언트가 어떤 요청을 했는지조차 모른다. 클라이언트 역시 `naver.com`이 리소스를 주었는지 프락시가 주었는지 알지 못한다.  

이런 프락시의 동작 방식 때문에, 많은 사고의 원인이 된다. 웹 서버를 개발하다 보면 서버에만 집중한 나머지 프락시를 놓치는 경우가 왕왕 있다고 한다. 
